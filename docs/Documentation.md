# Документация

## 1. Увод

Това е CLI приложение за извличане и визуализация на информация за процесора и системни параметри. Изходът може да бъде в табличен вид или като JSON, което позволява използването му както интерактивно, така и в автоматизирани скриптове.

Логиката е организирана в малък брой ясни функции, имената са еднозначни, а зависимостите са минимални. 

Основни възможности:
- Бърз преглед на CPU характеристиките
- Устойчиво поведение при липса на информация от ОС
- Type hints и PEP-8
- Може да се пакетира в standalone изпълним файл чрез PyInstaller

## 2. Функционалност

### 2.1 Какво показва приложението

**CPU информация**
- Модел/бранд на процесора (например Intel(R) Core(TM) i7…, AMD Ryzen…)
- Архитектура (x86_64, ARM64 и др.)
- Брой физически ядра
- Брой логически процесори/нишки
- Честоти: минимална, максимална и текуща (ако е налична през OS API)
- Натоварване (CPU usage %) към момента на стартиране
- Cache/Features – при възможност без root достъп

**Системна информация**
- Име на операционната система, версия и release
- Име на машината (hostname)
- Uptime (време на работа след последния boot)
- RAM памет: общо и свободно

### 2.2 Режими на работа
- Без аргументи: таблично резюме
- `--json`: чист JSON изход, подходящ за интеграция
- `--full`/`--verbose`: подробен режим с всички налични атрибути
- Устойчивост: програмата не крашва при липса на данни; показва "N/A" или "Unknown"

### 2.3 Технологии
- Python 3.10+
- `psutil` – системна информация
- `argparse` – CLI аргументи
- `platform` – базова информация за OS и CPU
- PyInstaller – build на еднофайлов изпълним файл
- `uv` (опционално) – управление на виртуална среда и зависимости

### 2.4 Изисквания
- **Преносимост**: работи на Windows, Linux и macOS без промени в кода
- **Надеждност**: липсващи или недостъпни параметри не водят до срив
- **Производителност**: извличането на данни е бързо и не натоварва системата
- **Поддържаемост**: модулна структура, ясни имена и docstrings
- **Удобство**: четим изход, опции за JSON и подробен режим

## 3. Как работи

Приложението има две основни части:

1) **Събиране на информация** – функции за извличане на данните от OS и `psutil` и тяхната нормализация
2) **Представяне на информация** – функции за визуализация в табличен вид или JSON

### 3.1 CPU информация
Извличането на CPU данни се базира на:
- `psutil.cpu_count(logical=False/True)` – физически и логически ядра
- `psutil.cpu_freq()` – текуща/мин/макс честота
- `psutil.cpu_percent(interval=0.1)` – моментно натоварване
- `platform.processor()` и `/proc/cpuinfo` (Linux) – модел/бранд
- `/proc/cpuinfo` и `/sys/devices/system/cpu/...` – флагове и cache размери (Linux, ако са налични)

Ако дадена информация не е налична (напр. честоти на някои macOS конфигурации), приложението използва "N/A" и продължава без прекъсване.

### 3.2 Системна информация
За системни данни се използват:
- `platform.uname()` – име, версия и release на OS
- `socket.gethostname()` – hostname
- `psutil.boot_time()` – време на последен boot
- `psutil.virtual_memory()` – RAM общо и свободно

Uptime се пресмята спрямо текущото време и boot timestamp, след което се форматира в човешки вид (например "2д 03:12:44").

## 4. Архитектура

Приложението е разделено на няколко модула с ясни отговорности:

- **Entry Point (`main.py`)**: парсване на аргументи, извикване на функции за събиране на данни, форматиране и печат на изхода
- **Providers (`cpuinfo_app/providers.py`)**: функции за събиране и нормализация на данни
- **Formatters (`cpuinfo_app/formatters.py`)**: функции за подготовка на текстов и JSON изход
- **Utils (`cpuinfo_app/utils.py`)**: помощни функции за форматиране и безопасни извиквания

### 4.1 Поток на данни

```
[CLI аргументи] -> main.py
                      |
                      v
         get_cpu_info() / get_system_info()
                      |
                      v
             {cpu: {...}, system: {...}}
                      |
                      v
        format_table() / format_json()
                      |
                      v
                stdout (CLI)
```

### 4.2 Функции

**get_cpu_info()**
- Събира CPU параметри от `psutil` и, при възможност, от системни файлове
- Връща речник с под-структури за честоти, features и cache

**get_system_info()**
- Извлича OS информация, hostname, uptime и RAM данни
- Преобразува uptime и RAM в човекочетим формат

**format_table()**
- Генерира табличен CLI изход
- Поддържа кратък и подробен режим чрез `verbose` флаг

**format_json()**
- Генерира форматиран JSON, подходящ за интеграция в скриптове

**utils**
- `safe_call()` – безопасно изпълнение с default стойности
- `format_bytes()` – форматиране на памет
- `format_duration()` – форматиране на uptime

### 4.3 Обработка на грешки

При всяко извличане на информация се прилага:
- `try/except` логика чрез `safe_call()` или локални защитени блокове
- Проверка за `None` или липсващи стойности
- Замяна с "N/A" при нужда

Това гарантира работа на различни операционни системи и дори при ограничени права.

### 4.4 Данни и форматиране

Вътрешният модел е речник (dict) с две основни секции: `cpu` и `system`. В тях се пазят както числови стойности (брой ядра, размер на RAM), така и текстови атрибути (модел, архитектура, версия на OS). Когато стойност липсва, се използва "N/A". Това позволява:
- безпроблемно сериализиране към JSON
- четимо визуализиране в табличен режим

Форматирането е разделено от логиката за събиране на данни, което позволява лесна смяна на представянето (например HTML или YAML изход) без промяна в доставчиците.

## 5. Библиотеки

### 5.1 psutil
`psutil` е стабилна и кросплатформена библиотека за системен мониторинг. Предоставя единен API за информация за CPU, памет и uptime. 

Причини за избора:
- Поддържа Linux, Windows и macOS
- Богата документация и активна поддръжка
- Високонадеждни измервания

Използвани функции:
- `psutil.cpu_count()`
- `psutil.cpu_freq()`
- `psutil.cpu_percent()`
- `psutil.boot_time()`
- `psutil.virtual_memory()`

### 5.2 argparse
`argparse` е част от стандартната библиотека на Python и предлага удобен начин за дефиниране на CLI аргументи, описания и помощни съобщения.

### 5.3 platform и socket
`platform` се използва за OS/CPU данни, а `socket.gethostname()` за името на машината. Леки, стандартни библиотеки.

### 5.4 PyInstaller
PyInstaller създава standalone изпълними файлове от Python скриптове. Предлага:
- Single-file build (`--onefile`)
- Добра съвместимост с Windows
- Широка употреба

Важно: PyInstaller създава изпълним файл за конкретната платформа, на която се прави build (Windows -> .exe, Linux -> ELF binary). Затова има отделен PowerShell скрипт за Windows, но същата команда може да се използва и в Unix среда.

Опцията `--onefile` обединява всички зависимости в един файл, което улеснява разпространението, но може да увеличи времето за стартиране (разархивиране във временна директория).

## 6. Използване

### 6.1 Стартиране

След инсталация на зависимостите:

```
python main.py
```

### 6.2 Аргументи
- `--json` – извежда чист JSON обект
- `--full` / `--verbose` – детайлен режим с всички налични параметри
- `--no-color` – изключва ANSI оцветяването

### 6.3 Примери

**Резюме в табличен вид**
```
python main.py
```

**JSON режим**
```
python main.py --json
```

**Подробен режим**
```
python main.py --full
```

## 7. Build и разпространение

### 7.1 Виртуална среда
Препоръчително е използване на виртуална среда:

```
uv venv .venv
```

Алтернативно (без uv):
```
python -m venv .venv
.venv\Scripts\activate  # Windows
```

### 7.2 Инсталация на зависимости

```
uv pip install -r requirements.txt
```

Алтернативно (без uv):
```
pip install -r requirements.txt
```

### 7.3 Създаване на изпълним файл

На Windows:

```
.\build_windows.ps1
```

Скриптът:
- Създава venv (ако липсва)
- Инсталира зависимостите
- Изпълнява PyInstaller с опция `--onefile`
  
Ако `uv` е наличен, скриптът го използва приоритетно. В противен случай използва стандартните `python` и `pip`.

Крайният резултат се намира в `dist\cpu_info.exe`.

### 7.4 Проверка на build
След build е добре да се:
- стартира `dist\cpu_info.exe` директно, за да се валидира работата без Python
- провери дали `--json` връща валиден JSON
- прегледа дали ANSI цветовете са подходящи за конкретната конзолна среда

## 8. Тестване

Базова проверка на следните сценарии:
- стартиране без аргументи
- JSON режим и валидиране с инструмент за JSON
- подробен режим с `--full`
- проверка на поведението при липса на определени данни (например на macOS)

За по-детайлна валидация може да се направи ръчно сравнение на показаните данни с такива от системни инструменти (Task Manager, `lscpu`, `top`).

## 9. Бъдещо развитие

Възможни разширения:
- изход във формат YAML или CSV
- опция за запис във файл
- информация за дискове и мрежови интерфейси
- unit тестове за `utils` и форматерите
