# Документация на курсовия проект

## 1. Увод и цели

Настоящият курсов проект е разработен в рамките на дисциплината „Разработка на софтуер“ и има за цел да демонстрира изграждане на професионално структуриран Python проект, който извлича и визуализира информация за процесора (CPU) и основни системни параметри. Приложението е реализирано като команден интерфейс (CLI) с възможност за формат на изхода както в табличен вид, така и като JSON, което го прави подходящо както за хора, така и за автоматизирани системи.

В настоящата версия акцентът е върху опростен, „университетски“ стил на реализация: логиката е организирана в малък брой ясни функции, имена са еднозначни и лесни за проследяване, а зависимостите са минимални. Този подход улеснява обучението, прегледа на кода и последващите разширения.

Основните цели на проекта са:
- Да предостави бърз и разбираем преглед на CPU характеристиките.
- Да предлага устойчиво поведение при липса на информация от операционната система.
- Да използва утвърдени библиотеки и добри практики (type hints, PEP-8, ясни имена).
- Да подготви процеса за пакетиране в самостоятелен изпълним файл чрез PyInstaller.

Проектът е ориентиран към учебни цели, но демонстрира практики, които са приложими и в реални инженерни среди, включително ясна архитектура, модулност и документация, позволяваща поддръжка и разширение.

## 2. Обхват и функционални изисквания

### 2.1 Минимално жизнеспособен продукт (MVP)
Приложението трябва да показва следната информация:

**CPU информация**
- Модел/бранд на процесора (например Intel(R) Core(TM) i7…, AMD Ryzen…).
- Архитектура (x86_64, ARM64 и др.).
- Брой физически ядра.
- Брой логически процесори/нишки.
- Честоти: минимална, максимална и текуща (ако е налична през OS API).
- Натоварване (CPU usage %) към момента на стартиране.
- Cache/Features – при възможност без root достъп.

**Системна информация**
- Име на операционната система, версия и release.
- Име на машината (hostname).
- Uptime (време на работа след последния boot).
- RAM памет: общо и свободно.

### 2.2 Поведение и UX изисквания
- Без аргументи: формат с таблично резюме.
- `--json`: чист JSON изход, подходящ за интеграция.
- `--full`/`--verbose`: подробен режим с всички налични атрибути.
- Устойчивост: програмата не трябва да крашва при липса на данни; трябва да показва “N/A” или “Unknown”.

### 2.3 Технологичен стек
- Python 3.10+
- `psutil` – системна информация
- `argparse` – CLI аргументи
- `platform` – базова информация за OS и CPU
- PyInstaller – build на еднофайлов изпълним файл
- `uv` (по избор) – управление на виртуална среда и зависимости

### 2.4 Нефункционални изисквания
Освен функционалните изисквания, проектът следва и няколко нефункционални цели:
- **Преносимост**: приложението трябва да работи на Windows, Linux и macOS без промени в кода.
- **Надеждност**: липсващи или недостъпни параметри не трябва да водят до срив.
- **Производителност**: извличането на данни трябва да е бързо и да не натоварва системата.
- **Поддържаемост**: модулна структура, ясни имена и docstrings улесняват поддръжката.
- **Удобство за потребителя**: четим изход, опции за JSON и подробен режим.
- **Учебна четимост**: кодът трябва да може да се разгледа и разбере от студент след първите курсове по програмиране.

## 3. Функционален анализ

Приложението е разделено на две основни функционални области:

1) **Събиране на информация** – функции за извличане на данните от OS и `psutil` и тяхната нормализация.
2) **Представяне на информация** – функции за визуализация в табличен вид или JSON.

### 3.1 CPU информация
Извличането на CPU данни се базира на комбинация от:
- `psutil.cpu_count(logical=False/True)` – физически и логически ядра.
- `psutil.cpu_freq()` – текуща/мин/макс честота.
- `psutil.cpu_percent(interval=0.1)` – моментно натоварване.
- `platform.processor()` и `/proc/cpuinfo` (Linux) – модел/бранд.
- `/proc/cpuinfo` и `/sys/devices/system/cpu/...` – флагове и cache размери (Linux, ако са налични).

Ако дадена информация не е налична (напр. честоти на някои macOS конфигурации), приложението използва “N/A” и продължава без прекъсване.

### 3.2 Системна информация
За системни данни се използват:
- `platform.uname()` – име, версия и release на OS.
- `socket.gethostname()` – hostname.
- `psutil.boot_time()` – време на последен boot.
- `psutil.virtual_memory()` – RAM общо и свободно.

Uptime се пресмята спрямо текущото време и boot timestamp, след което се форматира в човешки вид (например “2д 03:12:44”).

## 4. Архитектура и модулен дизайн

Приложението следва модулна архитектура с ясни отговорности, но в по-опростен процедурен стил, подходящ за учебни задачи. Основните слоеве са:

- **Entry Point (`main.py`)**: парсване на аргументи, извикване на функции за събиране на данни, форматиране и печат на изхода.
- **Providers (`cpuinfo_app/providers.py`)**: функции за събиране и нормализация на данни.
- **Formatters (`cpuinfo_app/formatters.py`)**: функции за подготовка на текстов и JSON изход.
- **Utils (`cpuinfo_app/utils.py`)**: помощни функции за форматиране и безопасни извиквания.

### 4.1 Диаграма на потока на данни (текстова)

```
[CLI аргументи] -> main.py
                      |
                      v
         get_cpu_info() / get_system_info()
                      |
                      v
             {cpu: {...}, system: {...}}
                      |
                      v
        format_table() / format_json()
                      |
                      v
                stdout (CLI)
```

### 4.2 Функции и отговорности

**get_cpu_info()**
- Събира CPU параметри от `psutil` и, при възможност, от системни файлове.
- Връща речник с под-структури за честоти, features и cache.

**get_system_info()**
- Извлича OS информация, hostname, uptime и RAM данни.
- Преобразува uptime и RAM в човекочетим формат.

**format_table()**
- Генерира табличен CLI изход.
- Поддържа кратък и подробен режим чрез `verbose` флаг.

**format_json()**
- Генерира форматиран JSON, подходящ за интеграция в скриптове.

**utils**
- `safe_call()` – безопасно изпълнение с default стойности.
- `format_bytes()` – форматиране на памет.
- `format_duration()` – форматиране на uptime.

### 4.3 Опростяване на структурата

За да бъде кодът по-подходящ за университетска среда:
- класовете са заменени от ясни функции с конкретна отговорност;
- логиката е организирана по модули, но без тежка йерархия;
- всички помощни операции са извън основния поток на `main.py`, което улеснява четенето и тестовете;
- имената са описателни и следват последователен стил.

Така се постига баланс между модулност и минимализъм, без да се жертва функционалността.

### 4.4 Обработка на грешки и устойчивост

Устойчивостта е основна част от дизайна. При всяко извличане на информация се прилага:
- `try/except` логика чрез `safe_call()` или локални защитени блокове.
- Проверка за `None` или липсващи стойности.
- Замяна с “N/A” при нужда.

Това гарантира, че приложението работи коректно на различни операционни системи и дори при ограничени права.

### 4.5 Данни, типове и форматиране

Вътрешният модел е речников (dict) с две основни секции: `cpu` и `system`. В тях се пазят както числови стойности (например брой ядра и размер на RAM), така и текстови атрибути (модел, архитектура, версия на OS). Когато стойност липсва, се използва текстов маркер “N/A”. Това позволява едновременно:
- безпроблемно сериализиране към JSON;
- четимо визуализиране в табличен режим.

Форматирането е разделено от логиката за събиране на данни, което позволява лесна смяна на представянето (например добавяне на HTML или YAML изход в бъдеще) без промяна в доставчиците.

## 5. Външни библиотеки и избор

### 5.1 psutil
`psutil` е стабилна, широко използвана и кросплатформена библиотека за системен мониторинг. Тя предоставя единен API за информация за CPU, памет и uptime. Избрана е, защото:
- Поддържа Linux, Windows и macOS.
- Има богата документация и активна поддръжка.
- Предоставя високонадеждни измервания.

Основни функции, използвани в проекта:
- `psutil.cpu_count()`
- `psutil.cpu_freq()`
- `psutil.cpu_percent()`
- `psutil.boot_time()`
- `psutil.virtual_memory()`

### 5.2 argparse
`argparse` е част от стандартната библиотека на Python и предлага удобен начин за дефиниране на CLI аргументи, описания и помощни съобщения. Изборът му е естествен за конзолни приложения.

### 5.3 platform и socket
`platform` се използва за OS/CPU данни, а `socket.gethostname()` за името на машината. Тези библиотеки са леки, стандартни и надеждни.

### 5.4 PyInstaller
PyInstaller е стандартен инструмент за създаване на standalone изпълними файлове от Python скриптове. Предлага:
- Single-file build (`--onefile`).
- Добра съвместимост с Windows.
- Широко използван в индустрията.

Важно ограничение е, че PyInstaller създава изпълним файл за конкретната платформа, на която се изпълнява build процесът (например Windows -> .exe, Linux -> ELF binary). Затова проектът включва отделен PowerShell скрипт за Windows, но същата команда може да бъде използвана и в Unix среда.

Създаването на един файл (`--onefile`) обединява всички зависимости в един бинарен файл, което улеснява разпространението, но може да увеличи времето за стартиране (разархивиране във временна директория). Това е приемлив компромис за учебен проект, ориентиран към лесна дистрибуция.

## 6. Ръководство за потребителя

### 6.1 Стартиране

След инсталация на зависимостите, приложението се стартира с:

```
python main.py
```

### 6.2 Аргументи
- `--json` – извежда чист JSON обект.
- `--full` / `--verbose` – детайлен режим с всички налични параметри.
- `--no-color` – изключва ANSI оцветяването.

### 6.3 Примерни сценарии

**1) Резюме в табличен вид**
```
python main.py
```

**2) JSON режим**
```
python main.py --json
```

**3) Подробен режим**
```
python main.py --full
```

## 7. Build и разпространение

### 7.1 Виртуална среда
Препоръчително е използване на виртуална среда:

```
uv venv .venv
```

Алтернативно (без uv):
```
python -m venv .venv
.venv\Scripts\activate  # Windows
```

### 7.2 Инсталация на зависимости

```
uv pip install -r requirements.txt
```

Алтернативно (без uv):
```
pip install -r requirements.txt
```

### 7.3 Създаване на изпълним файл

На Windows:

```
.\build_windows.ps1
```

Скриптът:
- Създава venv (ако липсва)
- Инсталира зависимостите
- Изпълнява PyInstaller с опция `--onefile`
  
Ако `uv` е наличен, скриптът го използва приоритетно. В противен случай използва стандартните `python` и `pip`.

Крайният резултат се намира в `dist\cpu_info.exe`.

### 7.4 Проверка на build артефакта
След build е препоръчително:
- да се стартира `dist\cpu_info.exe` директно, за да се валидира работата без Python;
- да се провери, че `--json` връща валиден JSON;
- да се прегледа дали ANSI цветовете са подходящи за конкретната конзолна среда.

## 8. Тестване и валидация

В учебен контекст е достатъчна базова проверка на следните сценарии:
- стартиране без аргументи;
- JSON режим и валидиране с инструмент за JSON;
- подробен режим с `--full`;
- проверка на поведението при липса на определени данни (например на macOS).

За по-детайлна валидация може да се направи ръчно сравнение на показаните данни с такива от системни инструменти (например Task Manager, `lscpu`, `top`).

## 9. Бъдещо развитие и идеи за разширение

Проектът е подходящ за последващи упражнения и разширения, например:
- добавяне на изход във формат YAML или CSV;
- добавяне на опция за запис във файл;
- включване на базова информация за дискове и мрежови интерфейси;
- създаване на минимални unit тестове за `utils` и форматерите.

Тези идеи могат да се използват като следващи задачи в университетска среда, без да нарушават текущия стабилен интерфейс.
